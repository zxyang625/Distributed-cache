# Distributed-cache

这是一个简单的分布式缓存项目，最开始为参照[groupcached](https://github.com/golang/groupcache)(go语言版memcached)的简化版[geecache](https://github.com/geektutu/7days-golang/tree/master/gee-cache)制作。麻雀虽小，五脏俱全，实现的功能有:

- 单机缓存和基于 HTTP 的分布式缓存
- 最近最少访问(Least Recently Used, LRU) 缓存策略
- 使用 Go 锁机制防止缓存击穿
- 使用一致性哈希选择节点，实现负载均衡
- 使用 protobuf 优化节点间二进制通信

在实现完基础的分布式缓存功能后，我决定对其进行魔改，完善其中功能，由于接口与groupcache接口相同，所以估计也能用在groupcache上，但是作者肯定不会让我PR的。一来我go才学了这么点时间，代码能力肯定垃圾，二来groupcache就是为了那样设定的，没必要在添加新功能。所以接下来的修改将是自娱自乐。

1. 2021年6月17号，添加了哨兵sentinel功能。

> 为什么要添加哨兵功能呢?因为我发现groupcache在某结点掉线后，没有相应的处理措施。这就导致了一旦结点A宕机，那么如果某数据处于A上而其他结点想要从A中获取数据时，与A进行连接会失败，在等待几秒后得到错误又要在本结点进行慢查询。所以我添加了单哨兵功能(为什么不多来几个哨兵?然后投票表决?因为我目前还不会，但我预留了相应借口以后再来实现)，哨兵能定时访问所有结点，每个结点给哨兵发送心跳包。当某结点下线后，因超时哨兵接收不到结点的心跳包，就会判定结点下线。然后将封装下线结点的信息分发给其他正常的结点，正常的结点会将下线结点(包括真实结点和虚拟结点)从集群中删除。这就使得当结点下线后其他结点能迅速反应过来并处理，跳过了HTTP请求超时的步骤。

